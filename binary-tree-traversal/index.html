<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Binary tree traversal | Weihan Kong</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="There are many ways to traverse a binary tree, here is a review of pre/in/post-order (recursive and iterative), level-order, bottom-up traversal and several other variations.">
<meta property="og:type" content="article">
<meta property="og:title" content="Binary tree traversal">
<meta property="og:url" content="http://whk.me/binary-tree-traversal/">
<meta property="og:site_name" content="Weihan Kong">
<meta property="og:description" content="There are many ways to traverse a binary tree, here is a review of pre/in/post-order (recursive and iterative), level-order, bottom-up traversal and several other variations.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Binary tree traversal">
<meta name="twitter:description" content="There are many ways to traverse a binary tree, here is a review of pre/in/post-order (recursive and iterative), level-order, bottom-up traversal and several other variations.">

  
    <link rel="alternative" href="/atom.xml" title="Weihan Kong" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Weihan Kong</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://whk.me"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-binary-tree-traversal" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/binary-tree-traversal/" class="article-date">
  <time datetime="2014-12-29T04:41:25.000Z" itemprop="datePublished">Dec 28 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Binary tree traversal
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2>Contents</h2><ul class="toc" style="list-style:none"><li class="toc-item toc-level-2"><a class="toc-link" href="#Recursive_tree_traversal"><span class="toc-number">1.</span> <span class="toc-text">Recursive tree traversal</span></a><ul class="toc-child" style="list-style:none"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pre-order"><span class="toc-number">1.1.</span> <span class="toc-text">Pre-order</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#In-order"><span class="toc-number">1.2.</span> <span class="toc-text">In-order</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Post-order"><span class="toc-number">1.3.</span> <span class="toc-text">Post-order</span></a></li></ul></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterative_tree_traversal"><span class="toc-number">2.</span> <span class="toc-text">Iterative tree traversal</span></a><ul class="toc-child" style="list-style:none"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pre-order-1"><span class="toc-number">2.1.</span> <span class="toc-text">Pre-order</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#In-order-1"><span class="toc-number">2.2.</span> <span class="toc-text">In-order</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Post-order-1"><span class="toc-number">2.3.</span> <span class="toc-text">Post-order</span></a><ul class="toc-child" style="list-style:none"><li class="toc-item toc-level-4"><a class="toc-link" href="#Two_stacks_method"><span class="toc-number">2.3.1.</span> <span class="toc-text">Two stacks method</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#One_stack_method_with_visited_nodes_set"><span class="toc-number">2.3.2.</span> <span class="toc-text">One stack method with visited nodes set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#One_stack_method_with_to-be-visited_right_children_set"><span class="toc-number">2.3.3.</span> <span class="toc-text">One stack method with to-be-visited right children set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#One_stack_method"><span class="toc-number">2.3.4.</span> <span class="toc-text">One stack method</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#One_stack_method_with_previous_visited_pointer"><span class="toc-number">2.3.5.</span> <span class="toc-text">One stack method with previous visited pointer</span></a></li></ul></li></ul></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Level-order_traversal"><span class="toc-number">3.</span> <span class="toc-text">Level-order traversal</span></a><ul class="toc-child" style="list-style:none"><li class="toc-item toc-level-3"><a class="toc-link" href="#Zigzag_level-order_traversal"><span class="toc-number">3.1.</span> <span class="toc-text">Zigzag level-order traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Populating_next_pointers_1"><span class="toc-number">3.2.</span> <span class="toc-text">Populating next pointers 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Populating_next_pointers_2"><span class="toc-number">3.3.</span> <span class="toc-text">Populating next pointers 2</span></a></li></ul></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bottom-up_traversal"><span class="toc-number">4.</span> <span class="toc-text">Bottom-up traversal</span></a></li></ul>
        <p>There are many ways to traverse a binary tree, here is a review of pre/in/post-order (recursive and iterative), level-order, bottom-up traversal and several other variations.<br><a id="more"></a></p>
<h2 id="Recursive_tree_traversal">Recursive tree traversal</h2>
<p>Recursive tree traversal is straightforward. Time complexity is <code>O(n)</code> if there are <code>n</code> nodes and space complexity is <code>O(n)</code>, because of the recursive call stack. If the tree is balanced, space complexity reduces to <code>O(lgn)</code>.</p>
<h3 id="Pre-order">Pre-order</h3>
<figure class="highlight java"><pre><div class="line"><span class="keyword">void</span> recursivePreorderTraversal(TreeNode root) {</div><div class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// base case</span></div><div class="line">    visit(root);</div><div class="line">    recursiveTraversal(root.left);</div><div class="line">    recursiveTraversal(root.right);</div><div class="line">}</div></pre></figure>

<h3 id="In-order">In-order</h3>
<figure class="highlight java"><pre><div class="line"><span class="keyword">void</span> recursiveInorderTraversal(TreeNode root) {</div><div class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// base case</span></div><div class="line">    recursiveTraversal(root.left);</div><div class="line">    visit(root);</div><div class="line">    recursiveTraversal(root.right);</div><div class="line">}</div></pre></figure>

<h3 id="Post-order">Post-order</h3>
<figure class="highlight java"><pre><div class="line"><span class="keyword">void</span> recursivePostorderTraversal(TreeNode root) {</div><div class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// base case</span></div><div class="line">    recursiveTraversal(root.left);</div><div class="line">    recursiveTraversal(root.right);</div><div class="line">    visit(root);</div><div class="line">}</div></pre></figure>

<h2 id="Iterative_tree_traversal">Iterative tree traversal</h2>
<h3 id="Pre-order-1">Pre-order</h3>
<p>Notice that pre-order traversal is essentially depth-first search (DFS) on a tree-structure graph, so we can use typical iterative DFS method as is. More specifically, use a stack to store to-be-visited <code>TreeNode</code> and expand each node on top of the stack.</p>
<figure class="highlight java"><pre><div class="line"><span class="keyword">void</span> iterativePreorderTraversal(TreeNode root) {</div><div class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">    stack.push(root);</div><div class="line">    <span class="keyword">while</span> (!stack.isEmpty()) {</div><div class="line">        TreeNode node = stack.pop();</div><div class="line">        visit(root);</div><div class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) stack.push(root.right); <span class="comment">// right child is pushed into stack first</span></div><div class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) stack.push(root.left);</div><div class="line">    }</div><div class="line">}</div></pre></figure>

<p>Time complexity is <code>O(n)</code> and space complexity is <code>O(n)</code>, because of the stack. If the tree is balanced, space complexity reduces to <code>O(lgn)</code>.</p>
<h3 id="In-order-1">In-order</h3>
<p>The idea of in-order traversal is to temporarily save the parent node and visit it after it’s left subtree is done. A stack can be used to store and retrieve parent nodes in LIFO manner.</p>
<p><code>node</code> variable plays the same role of <code>root</code> in the recursive approach, in which calling <code>recursiveInorderTraversal(root.left)</code> will push the local variable <code>root</code> in call stack. <code>node == null</code> in iterative approach is equivelent to the recursive call being returned in the recursive approach.</p>
<figure class="highlight java"><pre><div class="line"><span class="keyword">void</span> iterativeInorderTraversal(TreeNode root) {</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">    TreeNode node = root;</div><div class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.isEmpty()) { <span class="comment">// when root only has right child</span></div><div class="line">                                                <span class="comment">// stack will be empty and node = root.right</span></div><div class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) {</div><div class="line">            stack.push(node);</div><div class="line">            node = node.left;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            node = stack.pop(); <span class="comment">// node.left subtree is done by now</span></div><div class="line">            visit(node); <span class="comment">// move this line to case node != null, we get another pre-order traversal</span></div><div class="line">            node = node.right;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></figure>

<p>Time complexity is <code>O(n)</code> and space complexity is <code>O(n)</code>. If the tree is balanced, space complexity reduces to <code>O(lgn)</code>.</p>
<h3 id="Post-order-1">Post-order</h3>
<p>Post-order traversal is more complex because it is a non-tail recursion. In the recursive appraoch, <code>visit(root);</code> happens after the recursive calls to left and right subtrees.</p>
<h4 id="Two_stacks_method">Two stacks method</h4>
<p>Notice that post-order traversal is the reverse of pre-order traversal with the order of left and right subtrees reversed. So we can just do iterative pre-order traversal and store the result in another stack <code>postStack</code>. After the pre-order traversal is done, we can pop the nodes from <code>postStack</code> in a post-order manner.</p>
<figure class="highlight java"><pre><div class="line"><span class="keyword">void</span> iterativePostorderTraversal(TreeNode root) {</div><div class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">    Stack&lt;TreeNode&gt; postStack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">    stack.push(root);</div><div class="line">    <span class="keyword">while</span> (!stack.isEmpty()) {</div><div class="line">        TreeNode node = stack.pop();</div><div class="line">        postStack.push(node);</div><div class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) stack.push(node.left); <span class="comment">// order of left and right is reversed</span></div><div class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) stack.push(node.right);</div><div class="line">    }</div><div class="line">    <span class="keyword">while</span> (!postStack.isEmpty()) {</div><div class="line">        visit(postStack.pop());</div><div class="line">    }</div><div class="line">}</div></pre></figure>

<p>Time complexity is <code>O(n)</code> and space complexity is <code>O(n) + O(n) = O(n)</code>. If the tree is balanced, space complexity is still <code>O(lgn) + O(n) = O(n)</code>.</p>
<h4 id="One_stack_method_with_visited_nodes_set">One stack method with visited nodes set</h4>
<p>From the recursive approach we know that when we call <code>recursivePostorderTraversal(root.left)</code>, both <code>root</code> and <code>root.right</code> is stored in the call stack, so we should also save them in the iterative approach.</p>
<p>And because <code>recursivePostorderTraversal(root.right)</code> happens before <code>visit(root)</code>, <code>root</code> should be pushed into stack before <code>root.right</code>. Then we can move on to <code>root.left</code> as in <code>iterativeInorderTraversal()</code>.</p>
<p>The problem is when <code>node == null</code>, which is equivelent to method being returned in recursive approach, we can’t know whether the top node on stack is a “root” node whose both children are done traversal or a “right” node whose children are not traversed yet.</p>
<p>To solve this we can keep a visited set of nodes and check whether the children of the node on stack are already traversed.</p>
<figure class="highlight java"><pre><div class="line"><span class="keyword">void</span> iterativePostorderTraversal(TreeNode root) {</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">    HashSet&lt;TreeNode&gt; visited = <span class="keyword">new</span> HashSet&lt;TreeNode&gt;();</div><div class="line">    TreeNode node = root;</div><div class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.isEmpty()) {</div><div class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) {</div><div class="line">            stack.push(node);</div><div class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) stack.push(node.right);</div><div class="line">            node = node.left;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            node = stack.pop();</div><div class="line">            <span class="comment">// children is done</span></div><div class="line">            <span class="keyword">if</span> ((node.left == <span class="keyword">null</span> || visited.contains(node.left)) && (node.right == <span class="keyword">null</span> || visited.contains(node.right))) {</div><div class="line">                visit(node);</div><div class="line">                visited.add(node);</div><div class="line">                node = <span class="keyword">null</span>; <span class="comment">// this subtree is done</span></div><div class="line">            }</div><div class="line">            <span class="comment">// else, children is not done, node is the right child and</span></div><div class="line">            <span class="comment">// represents a right subtree that hasn't been traversed yet</span></div><div class="line">            <span class="comment">// right now node != null</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></figure>

<p>Time complexity is <code>O(n)</code> and space complexity is <code>O(n) + O(n) = O(n)</code>. If the tree is balanced, space complexity is still <code>O(lgn) + O(n) = O(n)</code> because we use a set of visited nodes. Even though we use only one stack, the complexity is not reduced.</p>
<h4 id="One_stack_method_with_to-be-visited_right_children_set">One stack method with to-be-visited right children set</h4>
<p>To reduce the space complexity of the one stack method, we want to avoid storing all nodes in the tree. Notice that in iterative in-order traversal, left subtree of any node popped from stack is sure to be done. So we visit that “middle” node and start traversing its right subtree.</p>
<p>In post-order traversal, we want to skip the visit part and come back to this “middle” node after the right subtree is done, so we should push it back to the stack before we move on to traverse its right subtree.</p>
<p>This leads to the problem that when we pop a node from stack, we don’t know whether its right child is done or not. So we can use a set again to remember all the right children that have been found but not traversed along the way.</p>
<figure class="highlight java"><pre><div class="line"><span class="keyword">void</span> postorderTraversal(TreeNode root) {</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">    HashSet&lt;TreeNode&gt; rightChildren = <span class="keyword">new</span> HashSet&lt;TreeNode&gt;();</div><div class="line">    TreeNode node = root;</div><div class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.isEmpty()) {</div><div class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) {</div><div class="line">            stack.push(node);</div><div class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) rightChildren.add(node.right);</div><div class="line">            node = node.left;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            node = stack.pop();</div><div class="line">            <span class="comment">// right children is done</span></div><div class="line">            <span class="keyword">if</span> (node.right == <span class="keyword">null</span> || !rightChildren.contains(node.right)) {</div><div class="line">                visit(node);</div><div class="line">                node = <span class="keyword">null</span>;</div><div class="line">            }</div><div class="line">            <span class="comment">// right children is not done</span></div><div class="line">            <span class="keyword">else</span> {</div><div class="line">                rightChildren.remove(node.right);</div><div class="line">                stack.push(node); <span class="comment">// push it back for visiting after right subtree is done</span></div><div class="line">                node = node.right;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></figure>

<p>Space complexity is reduced to <code>O(lgn)</code> if the tree is balanced because the set <code>rightChildren</code> can only get as large as the stack gets.</p>
<h4 id="One_stack_method">One stack method</h4>
<p>Alternatively, we can just store the right children in stack, too. Push <code>node.right</code> right before <code>node</code> into stack, when we pop a node from stack, its right subtree is not done if its right child is on top of the stack. So we can pop the right child and push the node back to the stack and traverse the right subtree.</p>
<p>The idea is essentially the same with method 2, but using only stack. The space complexity is the same.</p>
<figure class="highlight java"><pre><div class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span>(TreeNode root) {</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">    TreeNode node = root;</div><div class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.isEmpty()) {</div><div class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) stack.push(node.right); <span class="comment">// push right child first</span></div><div class="line">            stack.push(node);</div><div class="line">            node = node.left;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            node = stack.pop();</div><div class="line">            <span class="comment">// right children is done</span></div><div class="line">            <span class="keyword">if</span> (node.right == <span class="keyword">null</span> || stack.isEmpty() || node.right != stack.peek()) {</div><div class="line">                visit(node);</div><div class="line">                node = <span class="keyword">null</span>;</div><div class="line">            }</div><div class="line">            <span class="comment">// right children is not done</span></div><div class="line">            <span class="keyword">else</span> {</div><div class="line">                stack.pop();</div><div class="line">                stack.push(node); <span class="comment">// push it back for visiting after right subtree is done</span></div><div class="line">                node = node.right;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></figure>

<p>Complexity is the same with method 2.</p>
<h4 id="One_stack_method_with_previous_visited_pointer">One stack method with previous visited pointer</h4>
<p>We can also see that if a node is going to be visited, the previously visited node has to be its right child if it exists. So we can just use a <code>prev</code> variable to store the last visited node and the rest is the same with iterative in-order traversal.</p>
<figure class="highlight java"><pre><div class="line"><span class="keyword">void</span> postorderTraversal(TreeNode root) {</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">    TreeNode dummy = <span class="keyword">new</span> TreeNode(-<span class="number">1</span>); <span class="comment">// the virtual "first" visited node</span></div><div class="line">    TreeNode node = root, prev = dummy;</div><div class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.isEmpty()) {</div><div class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) {</div><div class="line">            stack.push(node);</div><div class="line">            node = node.left;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            node = stack.pop();</div><div class="line">            <span class="comment">// right children is done</span></div><div class="line">            <span class="keyword">if</span> (node.right == <span class="keyword">null</span> || prev == <span class="keyword">null</span> || node.right == prev) {</div><div class="line">                visit(node);</div><div class="line">                prev = node;</div><div class="line">                node = <span class="keyword">null</span>;</div><div class="line">            }</div><div class="line">            <span class="comment">// right children is not done</span></div><div class="line">            <span class="keyword">else</span> {</div><div class="line">                stack.push(node); <span class="comment">// push it back for visiting after right subtree is done</span></div><div class="line">                node = node.right;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></figure>

<p>Extra space usage is reduced but space complexity is the same with method 2 and 3.</p>
<h2 id="Level-order_traversal">Level-order traversal</h2>
<h3 id="Zigzag_level-order_traversal">Zigzag level-order traversal</h3>
<h3 id="Populating_next_pointers_1">Populating next pointers 1</h3>
<h3 id="Populating_next_pointers_2">Populating next pointers 2</h3>
<h2 id="Bottom-up_traversal">Bottom-up traversal</h2>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://whk.me/binary-tree-traversal/" data-id="0yx1dgjy3rvg267n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithms/">algorithms</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/binary-search-tree-basics/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Binary search tree basics</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithms/">algorithms</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/recommendation-systems/">recommendation systems</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/binary-tree-traversal/">Binary tree traversal</a>
          </li>
        
          <li>
            <a href="/binary-search-tree-basics/">Binary search tree basics</a>
          </li>
        
          <li>
            <a href="/heard-internship/">Heard internship</a>
          </li>
        
          <li>
            <a href="/sorting-basics/">Sorting basics</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 Weihan Kong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">

  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>



<script src="/js/script.js" type="text/javascript"></script>


  </div>
</body>
</html>